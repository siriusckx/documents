## 函数回顾与后置返回类型

### 函数定义
1. 形参如果在函数体内用不到，则可以不给形参变量名字，只给其类型。
2. 声明时，可以只有形参类型，没有形参名。
3. 把函数返回类型放到函数名字之前，这种写法，叫前置返回类型。
4. C++11当中，后置返回类型。
   >在函数声明和定义中，把返回类型写在参数列表之后。    
   >前面放auto,表示函数返回类型放到参数列表之后，而放在参数列表之后的返回类型是通过 -> 开始的。  
   ```
   auto func1(int a, int b) -> void; //函数声明
   auto func1(int a, int b) -> void; //函数定义
   ```

### 内联函数

>在函数定义前加inline，这个变通函数就变成了内联函数。
1. 使用场景
   >函数体很小，调用很频繁的这种函数。
2. inline影响编译器
   >在编译阶段对inline这种函数进行处理，系统尝试将调用该函数的动作替换为函数本体。通过这种方式，来提升性能。
3. inline只是我们开发者对编译器的一个建议
   > 编译器可以尝试去做，但具体做不做由编译器决定。
4. 内联函数要放在头文件中，普通的函数的定义不能放在头文件中（会报重复定义）
   > 将内联函数放在头文件中，以便cpp文件找到这个函数的本体代码并尝试将该函数的调用替换为函数体内的语句。
5. 优缺点
   * 代码膨胀的问题，所以内联函数体尽量要小。
   * 注意，各种编译器对inline的处理各不相同，inline函数尽量简单，代码尽可能少。循环、分支、递归调用尽量不要出现在inline函数中。
   * constexpr函数，可以看成是更严格的一种内联函数。
   * define宏展开也类似于inline
  
## 函数杂合用法总结
1. void返回值
   >返回值为void的函数，表示函数不返回任何类型，但我们可以调用一个返回类型是void的函数，让它作为另一个返回类型是void的函数。
2. 函数返回指针和引用的情况
   > 往一个不属于你的地址写值，会造成巨大隐患，函数返回指针
   ```
   int *myfunc()
   {
       int tmp = 9; //tmp使用完，这段内存被回收。
       return &tmp;
   }

   int *p = tmp;
   *p = 6;  //这里使用了一段被回收的内存，造成巨大隐患
   ```
   >往一个不属于你的地址写值，会造成巨大隐患，函数返回引用
   ```
   int &myfunc()
   {
       int tmp = 0; //tmp使用完，这段内存被回收
       return tmp;
   }

   int &k = myfunc();
   k = 10; //tmp使用完，这段内存被回收 
   ```
3. 没有形参可以保持形参列表为空（）,或者(void)
4. 如果一个函数如果不调用的话，则该函数可以只有声明部分，没有定义部分。
5. 普通函数，定义只能定义一次，声明可以声明多次。
6. 引用作形参的秒用
   >void func(int &ta, int &tb)，在C++中更习惯用引用类型的开通来取代指针类型的形能。
7. C++中，函数允许同名，但是形参列表的参数类型或者数量应该有明显的区别

## const char *、 char const *、 char * const 三者的区别
1. const char *p;
   > p指针指向的东西不能通过p来修改（p所指向的目标，那个目标中的内容不能通过p来改变）
2. char const *p 等价于const char *p
3. char * const p
   >这一旦指向了一个东西之后，就不可以再指向其他东西了，但可以修改p指向的目标中的内容。
4. const char * const p = str;
   >指针p的指向不能变，指向的内容也不能改变。

## const int &
1. const int &a =i; //代表a的内容不能通过a自己来修改
2. const int &a = 10; //这种是可以的
3. int &a = 10; //这种是不可以的

## 函数形参中带const
1. 可以防止你无意中修改形参的值，输入型参数
2. 实参类型可以更灵活
