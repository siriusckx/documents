## 隐式类型转换
>系统自动进行，不需要程序开发人员介入。

## 显式类型转换（强制类型转换）
### C语言风格的类型转换，直接（类型）
   ```
   int k = 5 % (int)3.2;

   int k = 5 % int(3.2);
   ```

### C++强制类型转换分为4种

> 通用形式
> 强制类型转换名<type>(express);
1. static_cast
   >静态转换，大家就理解成“正常转换”,编译的时候就会进行类型转换的检查。代码中要保证转换的安全性和正确性，和C语言中的强制类型转换这种差不多。c风格的强制类型转换，以及编译器能够进行的隐式类型转换，都可以用static_cast类显式完成。可用于：
   * 相关类型转换，比如整型和实型之间的类型转换
   * 子类转成父类类型（继承关系）
   * void * 与其他类型指针之间的转换，void *：无类型指针，可以指向任何指针类型（万能指针）
   ```
   int i = 10;
   int *p = &i;
   void *q = static_cast<void *>(p);
   void *db =static_cast<int *>(q);
   ```
   * 一般不能用于指针类型之间的转换，比如int * 转 double *等等。
2. dynamic_cast
   >主要用于运行时类型识别和检查，主要用于父类和子类之间转换。
3. const_cast
   >去除指针或者引用的const属性，该转换能够将const性质转换掉，编译时就会进行类型转换。
   ```
   const int ai =90;
   //int ai2 = const_cast<int>(ai); //ai不是指针也不是引用不能转。

   const int *pai = &ai;
   int *pai2 = const_cast<int *> (pai); //语法正确
   //*pai2 = 120; //写值行为，是属于一种未定义行为，大家不要这么干。调试的时候显示的是一个值，打印出来的又是另一个值。
   ```
4. reinterpret_cast
   >编译的时候就会进行类型转换的检查，重新解释。将操作数内容解释为另一种不同的类型（能把操作数类型都转了），用于处理无关类型的转换，也就是两个转换类型之间没有什么关系。常用于如下两种转换：
   * 将一个整型（地址）转换成指针，一种类型指针转抱成另一种类型指针，按照转换后的内容重新解释内存中的内容；
   * 也可以从一个指针转换成一个整型。
   > 被认为是危险的类型的转换，随便转，怎么搞都行，编译器都不报错。

>这四个强制类型转换都被称为“命名的强制类型转换（因为每一个都有一个名字并且各不相同）”

## 总结
1. 强制类型转换，不建议使用。强制类型转换能够抑制编译器报错。
2. 资料说：reinterpre_cast危险。使用const_cast意味着设计缺陷。
3. 如果实在需要使用类型转换不要再使用C语言风格的类型转换，使用C++风格的类型转换。
4. 一般static_cast和reinterpret_cast就能够取代C语言风格的类型转换。
5. reinterpret_cast只要好好用，合乎规则的用，不要乱用，其实reinterpret_cast很好用。
