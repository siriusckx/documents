## 基类指针、派生类指针

## 虚函数

> 问题：有没有一个解决办法，我们只定义一个对象指针，就能够调用父类，以及各个子类的同名函数？ 使用虚函数

## 虚函数的使用
1. 对象指针，它的类型必须是父类类型
2. 在父类中，函数声明之前必须要加virtual关键字声明函数成虚函数。
3. 子类函数声明前可加可不加，加上便于阅读。一旦某个函数（在基类）被声明成了虚函数，那么所有派生类（子类）中它都是虚函数。

总结一句：调用虚函数执行的是“动态绑定”，运行的时候才决定父类指针绑定到哪个对象上，并执行该对象上的函数。

```
Human *phuman = new Men();
phuman->eat();
phuman->Human::eat();  //调用父类虚函数
```

### override的使用
1. 为了避免在基类中写错虚函数，在C++11中，你可以在函数声明后面增加一个override关键字，这个关键字用在“子类”中，而且是虚函数专用。

### final的使用
1. 在父类的函数后面加上final, 在C++11中，子类中就不能覆盖用final指定的这个函数。

## 多态性
1. 多态性只是针对虚函数来说的
   >多态性：体现在具有继承关系的父类和子类之间，子类重新定义（重写）父类的成员函数eat()，同时父类把这个eat()函数声明成了virtual虚函数。通过父类的指针，只有到了程序运行时期，找到动态绑定到父类指针上的对象，这个对象它有可能是某个子类对象，也可能是父类对象。然后系统内部实际上是要造一个虚函数表，找到虚函数eat()的入口地址，从而调用父类或者子类的eat()函数，这就是运行时期的多态性。

## 纯虚函数

>纯虚函数： 是在基类中声明的虚函数， 但是它在基类中没有定义，但是要求任何派生类都要定义该虚函数自己的实现方法。
1. 纯虚函数实现方法
   >在基类的虚函数声明后面加一个 =0;
2. 一旦一个类中有纯虚函数，那么就不能生成这个类的对象了，该类就叫成为了抽象类，不能生成对象，主要目的是用来统一管理子类对象。
3. 在子类中必须实现基类中的纯虚函数

## 基类的析构函数一般写成虚函数（虚析构函数）

>结论：基类析构函数，未加virtual关键字，用基类指针 new 子类的对象，在delete的时候系统不会调用派生类的析构函数，会导致内存泄露。解决办法是在析构函数前加virtual关键字。

>记住：如果一个类，想要做基类，我们务必要把这个类的析构函数写成virtual析构函数。