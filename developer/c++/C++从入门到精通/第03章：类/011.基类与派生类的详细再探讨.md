## 派生类对象模型简介

## 派生类构造函数
1. 派生类实际是使用基类的构造函数来初始化它的基类部分，基类控制基类部分的成员初始化，派生类控制派生类部分成员的初始化。
2. 传递参数给基类构造函数问题：通过派生类的构造函数初始化列表；

## 即当基类又当子类
> 形成一个继承链

## 不想当基类的类
>在类名后面加final，则该类不能作为基类

## 静态类型和动态类型
```
Human *phuman = new Men(); //基类指针指向一个派生类对象
Human &q = *phuman; //基类引用绑定到派生类对象上
```
1. 静态类型：变量声明的时候的类型。静态类型编译的时候是已知的。
2. 动态类型：指的是这个指针/引用所代表的（所表达的）内存中的对象的类型。
   1. 动态类型是在运行的时候才知道。
   2. 只有基类指针和引用才会存在动态类型不一致的情况

## 派生类向基类的隐式类型转换
1. 基类能独立存在，也能作为派生类对象的一部分存在。
2. 并不存在从基类到派生类的自动类型转换
3. 编译器通过静态类型推断转换合法性，发现基能不能转换成派生类。

## 父类与子类之间的拷贝与赋值
1. 用派生类对象为一个基类对象初始化或者赋值时，只有该派生类对象的基类部分会被拷贝或者赋值，派生类部分会被忽略掉，也就是：基类只干基类自己的事情，多余的部分不会去操心。

