## 左值和右值
1. 左值：能用在赋值语句等号左侧的东西，它能够代表一个地址。
2. 右值：不能作为左值的值就是右值，右值不能出现在赋值语句中等号的左侧。
3. 结论：左值有时能够被当作右值使用。
   ```
   i = i +1; //i是个左值，不是个右值，虽然它出现在了等号右边
             //i用在等号右边的时候，我们说i有一种右值属性（不是右值）
             //i出现在等号左边，用的是i代表的内存中的地址，我们说i有一种左值属性。
    //一个左值，它可能同时具有左值属性和右值属性
   ```
4. 整个赋值语句的结果仍然是左值
5. 用到左值的运算符有哪些
   1. 赋值运算符
   2. 取地址 &
   3. string,vector 下标[]
   4. iterator
   5. ......
6. 通过看一个运算符在一个字面值上能不能操作，我们就可以判断运算符是否用到的是左值
7. 左值表达式就是左值，右值表达式就是右值
8. 左值：代表一个地址，所以左值表达式的求值结果，就得是一个对象，就得有地址。

## 引用分类
>三种形式的引用
1. 左值引用（绑定到左值）；
2. const引用（常量引用），也是左值引用，我们不希望改变值的对象。
3. 右值引用（绑定到右值）：它是个引用
   ```
   int &&a = 3; //绑定到一个常量
   ```

## 左值引用

1. 没有空引用的说法，左值引用初始化的时候就绑定左值。
```
int a = 1;
int &b { a }; //绑定到a
int &c; //错误，引用必须要初始化
int &c =1 ; //不可以，左值引用不能绑定到右值，必须绑定到左值。
const int &c = 1; //const引用可以绑定到右值，所以const引用特殊。
      int tempvalue = 1;//临时变量
      const int &c = tempvalue;
```

## 右值引用

1. 就是引用右值，也就是说，绑定到右值。
2. && 必须绑定到右值的引用
3. 右值引用也是引用
4. 右值引用大家理解成一个对象的名字
5. 临时变量被系统当做右值
6. const引用不公可以绑定到右值，还可以绑定到右值
7. 总结：
   >返回左值引用的函数，连同赋值，下标，解引用和前置递增递减运算符（--i），都是返回左值表达式的例子。返回非引用类型的函数，连同算术、关系，位以及后置递增运算符（i--），都生成右值，不能将一个左值引用绑定到这类表达式上，但是我们可以将一个const的左值引用或者一个右值引用绑定到这类表达式上。
   ```
   ++i //左值表达式。++i直接给变量i+1,然后返回i本身
   i++ //右值表达式，先用后加，先产生一个临时变量_tempi，记录i(_tempi = i)的值用于使用的目的，再给i+1,接着返回这个临时变量，临时变量是一个右值。
   ```
8. 重点强调
   1. r1虽然是右值引用（绑定到了右值），但r1本身它是左值（要把r1看成一个变量）。因为它在=左边呆着。
   2. 所有变量，看成左路值。因为他们是有地址的，而且你用右值引用也绑定不上。
   3. 任何函数里面边的形参都是左值。void f(int i, int &&w); w是右值引用，但w本身是左值。
   4. 临时对象都是右值。
   5. 右值引用的引入目的
      * C++11引入，&& 代表一种亲数据类型，引入新数据类型的目的如下
      * 提高程序运行效率。把拷贝对象变成移动对象来提高程序运行效率。
      * 移动对象如何发生？ && （应付移动构造函数，应付移动赋值运算符）用的。


## std::move函数

1. C++标准库里的新函数
2. std::move的能力只有一个：把一个左值强制转换成一个右值。带来的结果就是一个右值可以绑上去了。
   ```
   int i = 10;
   int &&ri20 = std::move(i); //把一个左值转换成一个右值，这就是move的能力

   int &&ri6 = 100;
   int &&ri8 = std::move(ri6);

   string st = "I love china!";
   string def = std::move(at); //string里的移动构造函数把st的内容转移到了def中去了，是因为触发了string的move。
   ```

## 左值右值总结说明
