## 继承的构造函数
>一个类只继承其直接基类（父类）的构造函数。默认，拷贝，移动构造函数是不能被继承的。如果基类含多个构造函数，则多数情况下，派生类会继承所有这些构造函数，但如下例外：
1. 如果在派生类中定义的构造函数与基类构造函数有参数列表，那么从基类中继承来的构造函数会被你在派生类中的定义覆盖掉。
2. 默认，拷贝，移动构造函数 不会被继承。
3. using A:A; 
   * 继承A的构造函数。using：让某个名字在当前作用域内可见。
   * 遇到这条代码的时候，会把基类的每个构造函数，都生成一个与之对应的派生类构造函数。
   * B(构造函数形参列表...):A(照抄的构造函数形参列表){}
   * 如果基类A的构造函数有默认参数的话，那么编译器遇到这种using A:A的时候，会帮我们在派生类B中构造出多个构造函数来。
        * 第一个构造函数是带有所有参数的构造函数
        * 基余的构造函数，每个分别省略掉一个默认参数
        * B(int i, int j, int k):A(i, j, k){}
        * B(int i, int j, int k):A(i, j){}
        * 如果类B，只含有using A:A 从A类继承来的构造函数的话，那么编译器是会给它合成默认的构造函数的。

## 多重继承

### 多重继承概述

### 静态成员变量

### 派生类构造函数与析构函数

### 从多个父类继承构造函数
>如果一个类从它的基类中继承了相同的构造函数，这个类必须为该构造函数定义它自己的版本。

## 类型转换

## 虚基类，虚继承（虚派生）
>派生列表中，同一个基类只能出现一次，但是如下两种情况例外：
1. 派生类可以通过它的两个直接基类分别继承同一个间接基类。
2. 直接继承某个基类，然后通过另一个基类间接继承该类。
>这样导致Grand被构造了两次，继承2次Grand是多余的，占空间，还可能产生名字冲突。

### 虚基类
>虚基类：无论这个类在继承体系中出现多少次，派生类中，都只包含唯一一个共享的虚基类（Grand）内容  
> 这种虚继承只对孙子类有影响，对父类和爷爷类无影响。
> 每个Grand的子类都要虚继承Grand类，只要其中一个不虚继承，这个Grand类就不是虚基类。
```
class A: public virtual Grand
{

}

class B: public virtual Grand
{

}

class c：public A, public B
{

}
```
>虚基类时，孙子类来生初始化爷爷类，如果孙子类还有孩子，则由C类的孩子来初始化C的爷爷类。换句话说，Grand类，是由最低层的派生类来初始化。  
>初始化顺序问题：先初始化虚基类部分，然后再按照派生列表，出现顺序来初始化其他类。 

## 总结
1. 小心虚继承，不太提倡使用。
2. 简单，不容易出现二义性的可以使用。