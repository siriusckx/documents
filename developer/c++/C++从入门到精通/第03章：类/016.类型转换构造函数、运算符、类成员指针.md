## 类型转换构造函数
1. 类型转换构造函数，是只带一个参数的构造函数，并且该参数不是本类的const引用
2. 在构造函数前加explicit禁止做隐匿类型转换
   ```
   TestInt ti = 12;  //隐式类型转换（调用了类型转换构造函数）
                     //编译器用12这个数字通过调用TestInt类的类型构造函数来创建一个临时的TestInt对象，并把这个对象构造到ti的内存空间
    TestInt ti1 = TestInt(12); //这是显示调用类型转换构造函数
    TestInt ti2(22); //调用了类型转换构造函数，但这里并没有进行隐式类型转换
   ```

## 类型转换运算符(类型转换函数)
> 能力和类型转换构造函数能力相反。
1. 格式operator type() const;
   ```
   operator int() const
   {
       //......
   }
   ```
2. const是可选项，const表示一般不应该改变待转换对象内容，但不是必须有const
3. type表示要转换成的某种类型，只要是能够作为函数返回的类型，都可以；数组指针，函数指针，引用等类型也都可以。
4. 类型转换运算符，没有形参（形参列表为空），因为类型转换运算符都是隐式执行的，同时也不能指定返回类型，但是，它却能返回一个type指定类型的值。
5. 必须定义成成员函数。

### 显式类型转换运算符
1. 前面加explicit
   ```
   explicit operator int() const
   {
       //......
   }
   ```
   ```
   int k = static_cast<int>(ti1);
   int k2 = ti1.operator int();
   ```

### 有趣的范例
1. 将对象转换成函数指针

## 类型转换的二义性问题

1. 在一个类中，建议只出现一个类型转换符
2. 明确的指定类型，尽量少用隐式转换

## 类成员函数指针
>是个指针，指向类成员函数

### 对于普通函数
1. 格式    
   * 类名::*函数指针变量名    （来声明普通成员函数指针）
   * &类名::成员函数名        （来获取类成员函数地址，这个是真正的内存地址）
2. 例子
   ```
   class CT
   {
       public:
           void ptfunc(int tmpvalue){}    //普通成员函数
           virtual void virtualfunc(int tmpvalue){} //虚成员函数
           static void staticfunc(int tmpvalue){} //静态成员函数
   };

   void(CT::*myfpointpt)(int); //一个类成员函数指针变量的定义，变量名字为myfpointpt
   myfpointpt = &CT::ptfunc;  //类成员函数指针变量myfpointpt被赋值
   ```
3. 大家注意
   1. 成员函数是属于类的，不属于类对象，只要有类在就有成员函数地址在。
   2. 若要使用这个成员函数指针，就必须把它绑定到一个类对象上才能调用。
   3. 使用函数指针的格式： 
      * “类对象名.*函数指针变量名” 
      * 如果是个对象指针，则 “指针名->*函数指针变量名”
   ```
   Ct ct, *pct;
   pct = &ct;
   (ct.*myfpointpt)(100); //对象ct，调用指针变量myfpointpt所指向的成员函数:ptfunc;
   (pct->*myfpointpt)(100);//对pct所指的对象，调用指针变量myfpointpt所指向的成员函数:ptfunc;
   ```

### 对于虚函数
>其使用和普通函数指针一样

   ```
   void (CT::*myfpointvirtual)(int) = &CT::virtualfunc; //这是个真正的内存地址
   ```

### 对于静态成员函数
1. 格式
   * 声明: “*函数指针变量名”
   * 使用：“&类名::成员函数名” //这个也是一个真正的地址
2. 例子
   ```
   void (*myfpointstatic)(int) = &CT::staticfunc;
   myfpointstatic(100);   //直接使用静态成员函数指针名即可使用
   ```
   
## 类成员变量指针

### 对于普通成员变量
```
int CT::*mp = &CT::m_a; //定义一个类成员变量指针, 地址:0x00000004{???},并不是真正意义上的指针.
//mp它不是指向内存中的某个地址,而是该成员变量,与该类对象指针之间的偏移量,只有和对象绑定起来时,才有用

CT testmp; 
//当生成类对象时,如果这个类中有虚函数表,则对象中,就会有一个指向这个虚函数表的指针,这个指针占用4个字节.

testmp.*mp = 189; 
//通过类成员变量指针来修改成员变量值,等价于 ct.m_a = 189
```

### 对于静态成员变量
> 这种指向静态成员变量的指针,是有真正的内存地址的;
```
int *stcp = &CT::m_stca; //定义一个静态成员变量指针
*stcp = 796;  //等价于CT::m_stca = 796
```

## 总结
1. C++对象模型(高级的知识)