## 模板概述
1. 所谓泛型以独立于任何特定类型的方式编写代码，使用泛型编程时，我们需要提供具体程序实例所操作的类习惯或者值。
2. 模板是泛型编程的基础，模板是创建类或者函数的蓝图或者公式，我们给这些蓝图或者公式提供足够的信息，让这些蓝图或者公式真正的转变具体的成类或者函数，这种转变
3. 模板支持将类型作为参数的程序设计方式，从而实现了对泛型程序设计的直接支持。也就是说，C++模板定义类函数时，将类型作为参数。

### 模板的分类
1. 函数模板
2. 类模板

## 函数模板的定义
```
template<typename T>
T funcadd(T a, T b)
{
    T addhe = a + b;
    return addhe;
}
```
1. 模板定义是用template关键字开头的，后边跟<>，<>里边叫模板参数列表<模板实参>,如果模板参数列表里多个参数，则用逗号分开。
   * <>里必须至少得有一个模板参数，模板参数前面有个typename/class关键字。
   * 如果模板参数列表里边有多个模板参数，那就要用多个typename/class; <typname T, typename Q>
2. 模板参数列表里边表示在函数定义中用到的“类型”或者“值”，也和函数参数列表类似。
   * 有的时候得指定模板实参给他，指定的时候我们要用<>把模板实参包起来。
   * 有的时候又不需要我们指定模板实参给他，系统自己能够根据一些值推断出来。

## 函数模板的使用
1. 调用的时候，编译器会根据你计用这个函数模板时的实参，去推断模板参数列表的参数（形参）的类型。
2. 模板参数有时候是推断出来的，推断的依据是根据你调用这个函数的实参来推断的。
3. 有时候，光凭借函数实参是推断不出来的，这个时候我们就要用<>来主动提供模板参数。
4. 例子
   ```
   int he = funcadd(3,1); // 3, 1系统认为是int，编译器能推断出来模板的形参是个int，所以T是int

   double he2 = funcadd(3. 1.5f); //报错，系统不知道推断成int还是double

   ```
5. 编译器在推断出来这个模板的形参类型之后，编译器就为我们实例化了一个特定版本的函数。

## 非类型模板参数
1. template<typename T>，T代表一个类型，是一个类型参数。那么在模板参数列表里边，还可以定义非类型参数；非类型参数代表的是一个值。
2. template<typename T, int s>,当模板被实例化时，这些非类型模板参数的值或者是用户提供的，或者是编译器推断的，都有可能。但是这些值必须都是常量表达式值，因为实例化这些模板是编译器在编译的时候来实例化的。
```
template<int a, int b>
int fncaddv2();

int result = funcaddv2<12, 13>(); //显式的指定模板参数---在尖括号中提供额外的信息

int a = 12;
int result = funcaddv2<a,13>(); //这不可以，非类型模板参数值必须是在编译的时候就能够确定，因为实例 化函数模板是在编译的时候确定的。

template<typename T, int a , int b>
int funcaddv2(T c)
{
    return c;
}

int result = fncaddv2<double, 11, 12>(13); //系统会以我们用<>类型传递的参数类型为准。

template<unsigned L1, unsigned L2>
inline  //可以将模板定义成内联函数
int charscomp(const char(&p1)[L1], const char(&p2)[L2]) 
{
    return strcmp(p1, p2);
}

int result = charscomp("test2","test");//没有提供非类型模板参数，系统会根据test2和test来计算长度，取代L1, L2.
```
3. 模板定义并不会导致编译器生成代码，只有在我们调用这个函数模板时，使编译器为我们实例化了一个特定版本的函数之后，编译器才会生成代码。
4. 模板的定义一般都放在一个.h文件当中