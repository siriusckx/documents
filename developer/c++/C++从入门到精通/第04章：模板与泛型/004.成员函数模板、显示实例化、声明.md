## 普通的成员函数模板
> 不管是普通类，还是模板类，其成员函数都可以是一个函数模板，称为“成员函数模板”，不可以是虚函数，否则编译器会报错。

## 类模板的成员函数模板
>类模板的模板参数必须使用<>指定，成员函数模板（函数模板）的参数可以推断。
1. 类模板的成员函数模板的写法
   >先写类模板的模板参数，再写函数模板的模板参数
   ```
   template<typename C>
   class A
   {
       template<typename T>
       A(T& t1, T& t2);
   };

   template<typename C>
   template<typename T>
   A<C>::A(T& t1, T& t2)
   {

   }
   ```
2. 类模板的成员函数（包括普通成员函数/成员函数模板）只有为程序所有（代码中出现了对该函数或者该函数模板的调用时）才进行实例化，如果某函数从未使用，由不会实例化该成员函数。

## 模板显示实例化和模板声明
>为了防止在多个.cpp文件中都实例化相同的类模板，所以C++11中提出了一个解决方法，我们称为“显式实例化”

```
A.cpp文件

//显示实例化手段中的实例化定义，这种实例化定义只需要一个.cpp文件写就可以
template A<float>;


other.cpp

//“显示实例化”手段中的“实例化声明”
//extern作用：不会在本文件中生成一个extern后边所表示的模板的实例化版本代码。
//extern目的：
extern template A<float>;
```
1. 模板的实例化定义只能有一个
2. 模板的实例化声明可以有多个
3. 不太推荐这种写法，在vs2017中，感觉没有起到效果。