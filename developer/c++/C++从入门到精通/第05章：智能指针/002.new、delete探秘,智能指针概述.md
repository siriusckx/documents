## new、delete探秘
1. new、delete是什么？
   * 是一个关键了或者运算符
   * malloc、free主要用于C语言编程，而new、delete用于C++编程中，这两者都用于动态的在堆中分配、释放内存。
   * new/delete比malloc/free要做更多的事情
     * new会调用构造函数
     * delete会调用析构函数
     * new、delete具备对堆上所分配内存进行初始化释放（反初始化）的能力，而这些能力是malloc和free是不具备的
2. new干了两件事
   * 分配内存（通过operate new()来分配内存）
   * 调用构造函数来初始化内存
3. delete干了两件事
   * 调用了析构函数
   * 释放内存（调用了operate delete()来释放内存）
4. 基本new如何记录分配内存大小供delete使用
   * new内部有记录机制，记录分配多少内存
   ```
   //内置类型
   int *a = new int(100); //占4个字节
   int *a = new int[2](); //占8个字节

   //有自定义板构函数的类
   class A
   {
       A(){}
       ~A(){}
   };

   A *a = new A();  // 占1个字节
   A *a = new A[2](); // 占6个字节


   //无自定义析构函数的类
   class B
   {
       B(){}
   };

   B *b =new B(); //占1个字节
   B *b = new B[2](); //占2个字节 
   ```

5. 为什么new、delete , new[] 、delete[] 要配对使用
   * 内置类型，如int不需要调用析构函数，所以new[]的时候系统并没有多分配4个字节
   * 对于int类型，new[], delete p或者delete []p, 效果是一样的
   * 结论：如果一个对象，使用new[ ]来分配内存，却用单独的delete（而不是delete[ ]）来释放内存，那么这个对象需要满足的条件是，对象的类型要么是内置类型或者无自定义的析构函数的类类型。
   ```
    //有自定义板构函数的类
   class A
   {
       A(){}
       ~A(){}
   };

   A *a = new A[2](); // 占6个字节
   delete a;  //在这里不使用 delete []a; 会造成崩溃，导致内存错乱

   （1）调用一次A的板构函数而不是2次，至少表示有内存泄露
   （2）调用operate delete(a) 释放内存，由于本应该从 0x0000012开始释放内存，却从 0x0000016释放，造成了其他的内存错乱，从而造成崩溃。
   ```
   * new的内容也千万不要用[]来进行释放，会造成错乱
   * 总而言之：new delete , new[] delete[] 要配对使用

## 智能指针概述

1. new delete的写法要非常小心，防止早早的释放，也防止忘记释放，总之，用好不容易
2. 裸指针：直接用new返回的指针，这种指针，强大，灵活，但是开发者全程维护，但容易出错。
3. 智能指针：可以理解成“裸指针”进行了包装，给裸指针外边包了一层，包装后给我们带来如下优点：
   * 最突出的优点：智能指针能够“自动释放所指向的对象内存”
4. C++标准库中有四种指针类型 std::
   * auto_ptr(c++98),已弃用
   * unique_ptr(C++11)：独占式指针，同一个时间内，只有一个指针能够指向该对象
   * shared_ptr(C+11)：共享式指针，多个指针指向同一个对象，最后一个指针被销毁时，这个对象会释放内存。
   * weak_ptr(C+11)：是辅助shared_ptr工作的

## shared_ptr基础
1. 共享所有权，不是被一个shared_ptr拥有，而是被多个shared_ptr之间相互协作；shared_ptr有额外开销。
2. 工作原理：引用计数，每个shared_ptr的拷贝都指向相同的内存。
   * 只有最后一个指向该内存的shared_ptr指针不需要再指向该对象时，那么这个shared_ptr才会去析构指向的内存。
   * 智能指针是explicit的，不可以进行隐式转换
   * 不要穿插使用裸指针和智能指针，常规初始化（shared_ptr和new配合）
3. make_shared函数，标准库里的函数模板，安全，高效的分配和使用shared_ptr
   ```
   shared_ptr<int> p2 = make_shared<int>(100);
   ```