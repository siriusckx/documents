## 互斥量（mutex）的基本概念
>保护共享数据，操作时，某个线程用代码把共享数据锁住、操作数据、解锁，其他想操作共享数据的线程必须等待解锁，锁定住，操作，解锁。
1. 互斥量是个对象，理解成一把锁，多个线程尝试用lock()成员函数来加锁这把锁，只有一个线程能够加锁成功，如果没有成功，代码执行则停留在lock这个地方。
2. 互斥量的使用要小心，保护数据不能少，少了会导致崩溃，没达到保护效果。多也会导致性能变慢。

## 互斥量的使用
1. lock(),unlock() 必须成对使用。
2. 注意：有lock没有unlock时，很难排查问题。
3. 为了防止大家忘记unlock(),引入了一个叫做std::lock_guard的类模板，在忘记释放锁的时候，它会自动帮你释放。
   ```
   std::mutext my_mutex;
   std::lock_guard<std::mutex> mylockguard(my_mutex);
   ```
   1. lock_guard使用后，lock和unlock就不能再使用了
   2. lock_guard的原理是，在构造函数中添加lock()，在析构函数中unlock()

## 死锁
1. 由至少两个锁头也就是两个互斥量才会产生。
2. C++中
   >比如我有两把锁（死锁这个问题是由至少两个锁头，也就是两个互斥量才能产生），金锁（JinLock）,银锁（YinLock）;
   >两个线程A,B
   1. 线程A执行的时候，这个线程先锁 金锁，把金锁 lock() 成功了，然后它去锁银锁。
   2. 出现了上下文切换
   3. 线程B执行了，这个线程先锁 银锁，因为银锁没有被锁，所以银锁会被锁成功，线程B接下来要去锁 金锁。
   4. 此时此刻，死锁就产生了
   5. 线程A因为拿不到银锁头，流程走不下去。（所有后边代码有解锁金锁的，但是流程走不下去，所以金锁头解不开）。
   6. 线程B因为拿不到金锁头，流程走不下去。（所有后边代码有解决银锁的，但是流程走不下去，所以银锁头解不开）。
   7. 大家都晾在这儿，你等我，我等你。
3. 解决方案
   >保证两个互斥量上锁的顺序一致。

## std::lock()
   > 一次性锁住两个或两个以上的互锁量，一个不行。如果其中一个没锁住，则它要将已锁住的全部释放，然后再锁，直到所有的全部都锁住了才继续往下执行。
   ```
   std::lock(my_mutex1, my_mutex2);

   my_mutex1.unlock();
   my_mutex2.unlock();
   ```

## std::lock_guard 和 std::adopt_lock的配合使用
   >std::adopt_lock是个结构体对象，起一个标记作用，表示这个互玉量已经lock()
    ```
    std::lock(my_mutex1, my_mutex2);

    std::lock_guard(my_mutex1, std::adopt_lock);
    std::lock_guard(my_mutex2, std::adopt_lock);
    ```