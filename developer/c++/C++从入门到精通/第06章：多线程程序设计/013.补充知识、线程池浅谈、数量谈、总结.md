## 补充一些知识
### 虚假唤醒
>可能由于多次notify_one后，wait被唤醒，但其实没有达到真正唤醒的要求，需要增加第二个参数，判断确实达到了取数据的条件，否则继续去wait，不要重复的去做无用的操作。

### atomic
1. 定时时初始化操作不允许
2. 拷贝赋值操作运算赋不可以
3. load():以原子方式读取内容
4. store():以原子方式写入内容

## 浅淡线程池
1. 场景设想
   1. 网络游戏：2W玩家，并不会每个人都创建一个线程
   2. 程序稳定性问题：偶尔创建一个线程代码，这种代码，让人感到不安
2. 线程池：把一堆线程放在一起，统一管理。
3. 实现方式：
   >一开始就初始化对应数量的线程，来一个请求后从线程池中取出一个线程来使用，使用完以后，并不将线程进行销毁。

## 线程创建数量谈
1. 线程开的数量极限问题， 2000个线程基本就是极限，再创建线程就崩溃。
2. 线程创建数量
   1. 采用某些技术开发程序，api接口提供商建议你 创建线程数量 = cpu数量，cpu*2, cpu*2 + 2
   2. 创建多线程完成任务，一个线程等于一条执行通路；100要堵塞充值，我们这里开110个线程，那是很合适的。
   3. 如果开很多个的线程，CPU进行线程的恢复和保存会占用太多的资源，建议，线程数量尽量不要超过500个，能控制在200个内

## C++11多线程总结
