## 引用折叠规则
1. 引用折叠（C++11）,这其中是一种规则，也有叫引用坍塌的
2. C++有明确含义的引用有两种：左值引用，右值引用
3. 引用折叠规则：有一个左值引用，最终为左值引用，其他的时候为右值引用（推导过程是这样，但编写代码时不能直接写）
   |第一组|第二组引用类型|最终类型|
   |--|--|--|
   |左值引用|右值引用|左值引用|
   |左值引用|左值引用|左值引用|
   |右值引用|右值引用|右值引用|
   |右值引用|左值引用|左值引用|
4. 引用的引用,是非法的。

## 转发
1. 函数模板目的：把收到的参数以及这些相对应的参数不变的转发给其他函数
2. 模板1：值传递
   ```
   template<typename F, typename T1, typename T2>
   void myFuncTemp(F f, T1 t1, T2 t2)
   {
       f(t1, t2);
   }

   void f(int a, int b)
   {
       // ....
   }
   ```
   >以上写法，会导致f函数参数为引用时，引用的特性丢失
2. 要保持上面转发的左值特性（当然如果有const属性，也需要保持）
   >可采用万能引用来做，实参的所有信息都会传递到万能引用当中去，从而让编译器导出来函数模板最终的形参类型。
   1. 模板2.1：万能引用，对传左值有效，但对传右值可能无效
   ```
   template<typename F, typename T1, typename T2>
   void myFuncTemp(F f, T1 &&t1, T2 &&t2)
   {
       f(t1, t2);
   }

   void f(int &a, int &b)
   {
       // ....
   }

   void g(int &&a, int &b)
   {
       //....
   }

   int j = 30;
   myFuncTemp(f, 20, j);

   myFuncTemp(g, 20, j); //这个编译会报错，t1是一个左值
   ```
   2. 右值的一个说明
   ```
   int &&youzhi = 80; //右值引用绑右值
   //虽然 &&youzhi是绑定到右值的，但是 yourzhi 本身是一个左值，因为youzhi是在等号左边呆着的；

   //int &z = youzhi; //证明了youzhi是一个左值

   //总结：*********youzhi是个左值，但是它的类型是一个右值引用。也就是说，左值引用这种概念 还是 右值引用这种概念，说的是 youzhi的类型，而不是youzhi本身。
   ```

## 完美转发
   > 以上转发会有问题，右值引用的时候，会出现问题，觖决方法如下：std::forward，专门为转发而存在，返回值要么是左值，要么是右值。
   ```
   template<typename F, typename T1, typename T2>
   void myFuncTemp(F f, T1 &&t1, T2 &&t2)
   {
       f(std::forward<T1>(t1), std::forward<T2>(t2));
   }

   ```
1. 对std::forward函数的理解
   1. 实参如果原来是左值，到了形参中还是左值；forward是按照形参原来的类型处理，所以std::forward之后还是个左值。
   2. 实参如果原来是个右值，到了形参中变成了左值，forwar是按照形参原来的类型来处理，所以std::forward之后还是个右值。
2. forward的能力就是保持原来实参的类型
3. 实参是左值还是右值信息，在万能引用中是会保存在T类型当中的，所以forward在使用的过程中，可以从中取出来

## std::move和std::forward的区别
1. std::move将实参进行左、右值的切换
2. std::forward保持左值和右值的特性。

## 再谈万能引用
1. 万能引用并不是一种新的引用类型，它是一种程序上的写法。
