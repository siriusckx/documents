## 用法简介
>C++11引入的一个重要的语法，lambda表达式，它定义了一个匿名函数，并且可以捕获一定范围内的变量。
```
auto f = [](int a)->int{
    return a+1;
};
```
1. 特点
   1. 是个匿名函数，也可以理解为“可调用的代码单元”，或者理解成未命名的内联函数。
   2. 它也有一个返回类型，一个参数列表，一个函数体。
   3. 与函数不同的是，lambda表达式可以在函数内部定义，这个是常规函数做不到的。
   4. lambda参数也可以设置默认值
2. 格式
   ```
   [捕捉列表](参数列表)->返回类型{函数体};
   ```
   1. 这是一个返回类型后置语法，很多时候lambda表达式返回值特别明显，可以省略。如果不能推断出来时，需要显示的给定返回值的类型。
   2. 没有参数的时候()也可以省略，但[]和函数体是不可以省略的。
   3. lambda调用方法和普通函数相同。
   4. lambda可以不返回任何数据类型，不返回时默认为void

## 捕获列表[]
> 通过捕获列表，捕获一定范围内的变量，这个范围指的是？
1. [] 不捕获任何变量，但不包括静态局部变量，局部静态变量不需要捕获，可以直接使用
2. [&] 捕获外部作用域中的所有变量，并作为引用在函数体内使用
   ```
   int i =9;
   auto f1 = [&]{
       i = 5;
       return i;
   };
   ```
3. [=]捕获外部作用域中的所有变量，并作为副本（按值）在函数中使用，可以用它的值，但不许给它赋值。
   int i = 9;
   auto f1 = [=]{
       i = 5; //非法
       return i;
   };
4. [this] 一般用于类中，捕获当前类中this指针，让lamba表达式可以访问类的成员变量，相当于成员函数。无论是 & = this 都可以访问this指针。
5. [变量名] 如果多个变量名，则彼此之间用 ，分隔，同时不捕获其他变量。
6. [&变量名] 按引用捕获变量名代表的变量，同时不捕获其他变量
7. [=, &变量名] 按值捕获所有的变量，但按引用捕获&中所指的变量，这里这个=必须写在前面，这个捕获列表，第一个位置表示的是默认捕获方式（隐式捕获方式），后续其他的都是显式捕获方式。
8. [&, 变量名] 同上，按引用捕获所有的变量，但变量名指定的按值进行捕获

## lambda表达式延迟调用和易出错细节分析
1. 错误1
   ```
   int x = 5;
   auto f = [=]{  //当遇到这一行时，也就是在捕获的这个时刻，x的值已经被复制到了这个f当中了
       return x;
   };
   x = 10;
   cout << f() << endl; //我们认为是10但实际是5
   ```
   >也就是说，凡是按值捕获的外部变量，在lambda表达式定义的这个时刻，所有这些外部变量就被复制了一份存储在lambda表达式中了，如果要想获取正确的结果，延迟来调用，可以采用&用来调用。

## lambda表达式中的mutable(易变的)
> 按值捕获的变量不能修改值，但是加了mutable后，可以修改，这个时候()不能省略
```
int x = 5;
auto f = [=]() mutable  //这里要加mutable，刚()参数列表之外的这个圆括号不能省略
{
    x = 6; 
    return x;
};
```

## lambda表达式的类型及存储
>C++11中 lambda表达式的类型被称为“闭包（Closure Type）”,闭包：函数内的函数（可调用对象），本质上就是lambda表达式创建的运行时期的对象；
>lambda表达式是一种比较特殊的，匿名的，类类型[闭我类]的对象（也就是定义了一个类类型，又生成一个匿名的该类型的对象），我们可以认为它是一个带有operator()的类类型对象，也就是仿函数（函数对象）。所以我们可以使用std::function和std::bind来保存和调用lambda表达式，每个lambda都会触发编译器给咱们生成一个独一无二的类类型；
```
std::function<int(int)> fc1 = [](int tv){return tv;};
cout << fc1(15) << endl;

std::function<int(int)> fc2 = std::bind( //bind第一个参数是函数指针，第二个参数开始就是真正的函数参数。
    [](int tv){
        return tv;
    },
    placeholders::_1
);

cout << fc2(15) << endl;
```
>不捕获任何变量的lambda表达式，也就是捕获列表为空，可以转换在一个普通的函数指针；
```
using functype = int (*) int; //定义一个函数指针类型；
functype fp = [](int tv){return tv;};
cout << fp(17) << endl;
```

## 语法糖的概念
> 语法糖：一种便捷写法的意思。让我们写的代码更简单，看起来也更容易理解，有效的减少代码出错的几率，lambda表达式，其实就是一种语法糖。

## lambda表达式再演示和优点总结
1. for_each简介，是个函数模板
   ```
   vector<int> myvector = {10, 20, 30, 40, 50};
   int isum = 0;
   for_each(myvector.begin(), myvector.end(), [&isum](int val){
       isum += val;
   });
   ```
2. find_if简介，也是个函数模板，用来查找满足一定条件的东西
   ```
   vector<int> myvector = {10, 20, 30, 40, 50};
   auto result = find_if(myvector.begin(), myvector.end(), [](int val){
       if( val > 30)
       {
           return true;
       }
       return false; //只要返回false，那么find_if就会不停的遍历myvector,一直到返回true或者遍历完为止
   });
   ```
   >实际上find_if返回的是指向满足第一个条件的迭代器，如果这样的元素不存在，则这个迭代器会返回指向myvector.end()