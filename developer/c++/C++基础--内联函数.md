# 内联函数
>&emsp;&emsp;函数的引入可以减少程序的目标代码，实现程序代码的共享。但是，函数调用也需要一些时间和空间方面的开销，因为调用函数实际上将程序执行流程转移到被调函数中，被调函数的程序代码执行完后，再返回到调用的地方。这种调用操作要求调用前保护现场并记忆执行的地址，返回后恢复现场，并按原来保存的地址继续执行。对于较长的函数这种开销可以忽略不计，但是对于一些函数体代码很短，但又被频繁地调用的函数，就不能忽视这种开销。引入内联函数正是为了解决这个问题，提高程序的运行效率。
>
>&emsp;&emsp;在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替换。由于在编译时将函数体中的代码替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间开销上不象函数调用时那么大，可见它是以目标代码的增加为代价来换取时间的节省。 

# inline函数
>我们看下面的函数，函数体中只有一行语句： 
```
double Average(double total, int number)
　　{
　　　return total/number;
　　} 
```
>&emsp;&emsp;定义这么简单的函数有必要吗？实际上，它还是有一些优点的：第一，它使程序更可读；第二，它使这段代码可以重复使用。但是，它也有缺点：当它被频繁地调用的时候，由于调用函数的开销，会对应用程序的性能有损失。例如，Average在一个循环语句中重复调用几千次，会降低程序的执行效率。  
>&emsp;&emsp;那么，有办法避免函数调用的开销吗？对于上面的函数，我么可以把它定义为内联函数的形式：
```
inline double Average(double total, int number)
　　{
　　　return total/number;
　　} 
```
>&emsp;&emsp;上面的内联函数同它的非内联函数相比，仅仅是多了一个关键字inline，它们在功能上并没有区别：前者也是有两个形参，一个double型，一个int型，返回值是double型，且两个形参相除后所得的商作为结果返回。但是，编译器对这两个函数的调用过程的处理是不同的。对于内联函数的调用，编译器是将其函数体放在调用的地方，没有非内联函数调用时的栈内存的创建和释放开销。但是，所执行的计算是完全相同的。
# 使用内联函数时应注意以下几个问题：
1. 在一个文件中定义的内联函数不能在另一个文件中使用。它们通常放在头文件中共享。
2. 内联函数应该简洁，只有几个语句，如果语句较多，不适合于定义为内联函数。 
3. 内联函数体中，不能有循环语句、if语句或switch语句，否则，函数定义时即使有inline关键字，编译器也会把该函数作为非内联函数处理。
4. 内联函数要在函数被调用之前声明。例如下面的代码将内联函数放在函数调用之后声明，不能起到预期的效果。
```
#include <iostream.h>
int increment(int i);
inline increment(int i)
{
　i++;
　return i;
}
void main()
{
　int i=0;
　while(i<3)
　{
　　i=increment(i);
　　cout<<"i is "<<i<<endl;
　}
}
这段程序的输出结果为：
i is 1
i is 2
i is 3
```
>　如果我们修改一下程序，将内联函数的定义移到main()之后：
```
#include <iostream.h>
int increment(int i);
void main()
{
　int i=0;
　while(i<3)
　{
　　i=increment(i);
　　cout<<"i is "<<i<<endl;
　}
}
//内联函数定义放在main()函数之后
inline int increment(int i)
{
　i++;
　return i;
}
```
> 内联函数在调用之后才定义，这段程序在编译的时候编译器不会直接把它替换到main中。也就是说实际上"increment(int i)"只是作为一个普通函数被调用，并不具有内联函数的性质，无法提高运行效率。

本文引用自[C++基础--内联函数](https://blog.csdn.net/gaoxiaowei/article/details/2866773)
