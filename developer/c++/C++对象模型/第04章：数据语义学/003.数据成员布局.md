## 观察成员变量地址规律
1. 普通成员变量的存储顺序，是按照从类中的定义顺序从上到下来的。
2. 比较晚出现的成员变量，在内存中的地址更高。
3. 类定义中public、private不影响size_of的大小
   
## 边界调整，边界对齐
> 某些因素会导致成员变量的内存地址不连续。
1. 如边界调整（字节对齐），为了提高效率，编译器自动调整。
   >调整：往成员变量之间填补一些字节，使用类对象sizeof,字节数凑成一个4的整数倍，8的整数倍。
2. 网络编程中为了统一字节对齐问题，引入一个概念叫一字节对齐（不对齐）；
   ```
   #pragma pack(1)  //以下定义为1字节对齐，即不对齐
   class A
   {
    public:
       int m_a;
       int m_b;
       char m_c;
   }
   #pragma pack() //解除不对齐，编译器自己进行内存对齐
   ```
3. 有虚函数时，编译器往类定义中增加vptr虚函数表指针：内部的数据成员

## 成员变量偏移值的打印
1. 成员变量偏移值:就是这个成员变量的地址，离对象首地址的距离。
   ```
   &A::m_a;   //这个对应的是成员变量的偏移地址

   A a;
   &a.m_a;    //成员变量m_a的地址
   ```