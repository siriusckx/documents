## 静态动态类型
1. 静态类型：对象定义时的类型，编译期间就确定好的。
   ```
   Base base; //base静态类型是Base，没有动态类型
   Derive derive;   //derive的静态类型是Derive，没有动态类型
   Base *pbase;  //pbase的静态类型是Base，没有动态类型，至少目前没有，因为它没有指向任何对象
   Base *pbase2 = new Derive(); //pbase2的静态类型是Base，动态类型是Derive
   ```
2. 动态类型：对象目前所指向的类型（运行的时候才决定的类型）
   1. 一般只有指针或者引用才有动态类型的说法，而且一般是指父类的指针或引用。
   2. 动态类型在执行的过程中是可以改变的。
   
## 静态动态绑定
1. 静态绑定：绑定的是静态类型，所对应的函数或者属性依赖于对象的静态类型，发生在编译期。
2. 动态绑定：绑定的是动态类型，所对应的函数或者依赖于对象的动态类型，发生在运行期。
> 普通成员函数是静态绑定，而虚函数是动态绑定；缺省参数一般是静态绑定。

## 继承的非虚函数坑
> 普通函数是静态绑定，换句话说，myfunc()是普通成员函数，这里到底调用父类的myfunc还是子类的myfunc取决于调用者的静态类型。
   ```
   Derive derive;
   Derive *pderive = &derive;
   pderive->myfunc(); //调用的是Derived的myfunc,因为pderive的静态类型是Derive

   Base *pbase = &derive;
   pbase->myfunc(); //调用的是Base的myfunc,因为pbase的静态类型类型是Base
   ```
1. 结论：不应该在子类中重新定义一个继承来的非虚函数。

## 虚函数的动态绑定
> 虚函数是动态绑定，换句话说，myvirfunc是虚函数，这里到底调用父类的myvirfunc还是子类的myvirfunc取决于调用者的动态类型
  ```
  Base base;
  pderive->myvirfunc(); //执行Derive的myvirfunc
  pbase->myvirfunc(); //pbase动态类型是Derive,而虚函数是动态绑定，参照它的动态类型，调用Derive的myvirfunc
  pbase = &base;
  pbase->myvirfunc(); //pbase动态类型指向了Base,调用Base的myvirfunc
  ```

## 重新定义虚函数的缺省参数坑
1. 函数的缺省参数是静态绑定，所以绑定到不同类型的动态类型，其缺省参数是不一样的。
2. 结论：不要重新定义虚函数的缺省参数的值。

## C++中多态性的体现
1. 多态性概念
   >多态，必须是存在虚函数，没有虚函数，绝不可能存在多态，有虚函数并且调用虚函数。
   1. 代码实现上
      >当我们调用一个虚函数时，走的是不是通过虚函数表来找到虚函数的入口地址，然后去执行函数，如果走的是这个途径，那就是多态，如果不走这个途径，它就不是多态。
      ```
      A *pa =new A();
      pa->myvirfunc(); //多态

      A a;
      a.myvirfunc(); //不是多态

      A *pal;
      pal = &a;
      pal->myvirfunc(); //多态
      ```
   2. 表现形式上
      1. 有继承关系，有父类有子类，父类中必须有虚函数（这意味着子类中一定有虚函数），子类重写父类的虚函数。
      2. 父类指针指或引用指向子类对象。
      3. 当以父类指针或者引用调用子类中重写了的虚函数时，我们就能看出来多态的表现了，因为调用的是子类的虚函数。


