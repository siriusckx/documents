## 多继承下的虚函数

## 如何成功删除用第二个基类指针new出来的继承类对象
1. 我们要删除的实际是整个Derive()对象
2. 要能够保证Derive()对象的析构函数被正常调用
```
Base2 *pb2 = new Derive();
delete pb2;
```
3. 编译器会调用Base2的析构函数，还是调用Derive的析构函数？
4. 执行delete pb2时，系统的动作是什么？
   1. 如果Base2里没有析构函数，编译器会直接删除以pb2开头的这段内存，一定报异常，因为这段内存压根就不是new起始的内存。
   2. 如果Base2里有一个析构函数，但这个析构函数是一个普通函数（非虚析构函数），那么当delete pb2时，这个析构函数就会被系统调用，但是delete的仍旧是pb2开头这段内存，所以一定报异常。因为这段内存根本不是new起始的内存。析构函数如果不是虚函数，编译器会实施静态绑定，静态绑定意味着你delete Base2指针时，删除的内存开始地址就是pb2的当前地址。
   3. 如果Base2里有一个虚析构函数，调用次序就会变成 ~Derive(), ~Base2(), ~Base(),Derive里就算没有虚析构函数，因为Base2里有虚析构函数，编译器也会给Derive生成虚析构函数，为了调用~Base2()和~Base()虚析构函数。
   4. 要求大家，凡是涉及到继承的类，都把对应的虚析构函数加上。
5. Derive类的第二个虚函数表中发现了trunk字样
   >一般这玩意在多重继承当中（从第二个虚函数开始可能就会有），用于this指针的调整，trunK其实是一段汇编代码，做以下两个事情
   1. 调整this指针
   2. 调用~Derive()析构函数。
