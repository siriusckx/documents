## 指向成员函数的指针
> 成员函数地址，编译时就确定好的。但是，调用成员函数，是需要通过对象来调用的。所有常规（非静态成员）函数，要想调用，都需要一个对象来调用它。
```
A mya;
void (A::*mypoint)(int tempvalue) = &A::myfunc1; //定义一个成员函数指针，并给初值
mypoint = &A::myfunc2; //给成员函数指针赋值
(mya.*mypoint)(15); //通过成员函数指针来调用成员函数，必须要通过对象的介入才能调用

A *pmya = new A();
(pmya->*mypoint)(10); 
```
>它们之间的性能都差不多

## 指向虚成员函数指针及vcall进一步谈
1. vcall (virtual trunk) = virtual call; 虚调用
2. 它代表一段要执行的代码的地址，这段代码引导咱们去执行正确的虚函数，或者我们直接把vcall看成虚函数表，如果这么看的话，那么vcall{0}代表的就是虚函数表里的第一个函数，vcall{4}就代表虚函数表里的第二个虚函数。
3. 完善理解：&A::myvirfunc,打印出来的是一个地址，这个地址中有一段代码，这个代码中记录的是该虚函数表中的一个偏移值。有了这个偏移值，再有具体的对象指针，就可以知道调用的是哪个虚函数表里面的哪个虚函数。
4. 成员函数指针里，保存的可能是一个vcall(vcall trunk)地址（虚函数），那么也可能是一个真正的成员函数地址，如果是一个vcall地址，那么vcall能引导编译器找出正确的虚函数表中的地址。