## 拷贝构造函数相关的临时对象
1. 编译器优化和不优化时的区别
   
## 拷贝赋值运算符相关的临时对象
1. 相对来说，拷贝构造要比赋值构造要快一些，优化也要优化得多一些

## 直接运算产生临时对象
1. 临时对象的析构，是整行语句完成后的最后一步，才会析构
2. 临时对象的摧毁
   ```
   const char *p = (string("123") + string("456")).c_str(); //这一句是有问题的，这行完成后临时变量就被析构掉了。

   string ss = string("123")+string("456");
   const char *q = ss.c_str(); //这一句没有问题
   ```