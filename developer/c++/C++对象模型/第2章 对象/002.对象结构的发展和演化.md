## 对象结构的发展和演化
1. 非静态的成员变量：跟着类对象走（存在对象内部），也就是每个类对象都有自己的成员变量；
2. 静态成员变量：跟对象没有什么关系，肯定不会保存在对象内部，是保存在对象外部（表示所占用的内存空间和对象无关）的。静态成员变量是跟着类走的。
3. 成员函数：不管静态的还是非静态的，全部都保存在类对象之外，所以不管几个成员函数，对象的sizeof都不会变。
4. 虚函数：不管几个虚函数，sizeof()都是多了4个字节。类里只要有一个虚函数（或者至少有一个虚函数），这个类会产生一个指向虚函数的指针。有两个虚函数，那么这个类，就会产生两个指向虚函数的指针。类本身，指向虚函数的指针（一个或者一堆）要有地方存放，这个表格我们就称为“虚函数表（virtual table[vtbl]）”，这个虚函数表一般是保存在可执行文件中的，在程序执行的时候载入到内存中来。虚函数表是基于类的，跟着类走的。
5. 虚函数，类对象这4个字节的增加，其实是因为虚函数的存在，导致系统往类对象中添加了一个指针，这个指针正好指向这个虚函数表，很多资料把这个指针叫vptr;vptr由系统在适当的时机（比如构造函数中通过增加额外的代码来实现）
## 总结
1. 静态数据成员不计算在sizeof内。
2. 普通成员函数和静态成员函数不计算在类对象的sizeof内
3. 虚函数不计算在类对象的sizeof内，但是虚函数会让类对象的sizeof增加4个字节以容纳函数表指针。
4. 虚函数表[vtbl]是基于类的（跟着类走，跟对象没关系，不是基于对象的）；
5. 如果有多个数据成员，那么为了提高访问速度，某些编译器可能会将数据成员之间的内存占用比例进行调整。（内存字节对齐）
6. 不管什么类型指针char *p,int *q;该指针占用的内存大小是固定的。
7. 类对象大小的组成：非静态成员变量所占的内存总量以及这些成员变量之间内部字节对齐所额外占用的内存；若有虚函数，则会产生虚函数表指针（vptr）。