## 为什么需要exec函数
1. fork子进程是为了执行新程序
2. 可以直接在子进程的if中写入新程序的代码
   > 这样可以，但是不够灵活，因为我们只能把子进程程序的源代码贴过来执行（必须知道源代码，而且源代码太长了也不好控制），譬如说我们希望子进程来执行ls -la命令就不行了（没有源代码，只有编译好的可执行程序）
3. 使用exec运行新的可执行程序
   >exec族函数可以直接把一个编译好的可执行程序直接加载运行
   
## exec族的6个函数介绍
### execl 和 execv
1. 这两个函数是最基本的exec，都可以用来执行一个程序，区别是传参的格式不同。execl是把参数列表（本质上是多个字符串，必须以NULL结尾）依次排列而成（l其实就是list的缩写），execv是把参数列表事先放入一个字符数组中，再把这个字符串数组传给execv函数。例：
```
execl("/bin/ls", "ls", "-l", "-a", NULL);
```
```
char* const arg[] ={"ls", "-l", "-a", NULL} ;
execv("/bin/ls", arg);
```

### execlp 和 execvp
1. 这两个函数在上面2个基础上加了p，区别是：上面2个执行程序是必须指定可执行程序的全路径（如果exec没有找到path这个文件则直接报错）,而加了p的传递的可以是file(也可以是path，只不过兼容了file。加了p的这两个函数会首先去找file,如果找到则执行，如果没找到则会去环境变量PATH所指定的目录下去找，如果找到则执行如果没找到则报错);

### execle 和 execvpe
1. 这两个函数较基本exec来说加了e，函数的参数列表中也多了一个字符串数组envp形参，e就是environment环境变量的意思，和基本版本的exec的区别就是：执行可执行程序时会多传一个环境变量的字符串数组给待执行的程序。
2. main函数的原型还有其他的类型
```
 int main(int argc, char **argv)
```
```
   int main(int argc, char **argv, char**env)
```