## 子进程继承父进程中打开的文件
1. 上下文：父进程先open打开一个文件得到fd，然后再fork创建子进程。之后在父子进程中各自write向fd中写入内容。
2. 测试结论是：接续写。实际上本质原因是父子进程之间的fd对应的文件指针是彼此关联的（很像O_APPEND标志后的样子）
3. 实际测试时有时候会看到只有一个，有点像分别写。但是实际不是，原因是其中一个进程先写完后，退出了，导致文件被关闭。

## 父子进程各自独立打开同一个文件实现共享
1. 父进程打开1.txt,往里面写内容，子进程打开1.txt往里面写内容;
2. 结论是：分别写，原因是父子进程分离后才各自打开的1.txt。这时候两个进程的PCB已经独立了。两个进程打开的文件件是独立的。
3. open时使用O_APPEND标志会如何？实际测试结果表明O_APPEND标志可以把父子进程各自独立打开的fd的文件指针给关联起来，实现接续写。
## 总结
1. 父进程在没有fork之前自己做的事情对子进程有很大影响，但是父进程fork之后在自己的if里做的事情就对子进程没有影响了。本质原因是fork内部实际上已经复制父进程的PCB生成了一个新的父进程，并且fork返回时子进程已经完全和父进程脱离并且独立被OS调度执行。
2. 子进程最终目的是要独立运行其他的程序