# 一、使用到的技术
1. shmtcp
   >外部接收程序的数据结构得改成定长的结构，不支持智能指针或者string这种变长的。
2. kfifo
3. shmq
   > 支持跨进程，稍微比kfifo复杂一点，不兼容windows,shmq就是一个ringbuffer
4. ringbuffer
   > 纯定长的
5. 多播的使用
   > 在多线程下，需要使用多播，以前少发送端的延迟

# 二、可能占用时间的点

# 三、一些重要的点
1. 每个线程单独一个ioservice,不需要strand
2. 累积可能会导致延迟，这其中有一个累积效应，数据量大和小都会有累积的效果
3. 统计方法是否有问题，非必要的部分不要加到统计方法里面
4. 尽量少转线程，数据堵的话，可以让它堵在网络里，不进入计时范围
5. 打印log也会耗时，一行log耗时6us左右
6. 接收程序慢是不是用的rpc，是不是可以直接走环形队列。
7. 将string改成char[]
8. 将vector改成定长的数组
9. 可以对kfifo、shmq和ringbuffer做一下benchmark
10. 将对应的线程，绑定到指定的CPU上面
    >这样可能会引起cpu soft lockup，导致服务器崩溃
11. gettimeofday 和 clock_gettime的关系
12. 使用内存结构保存时间，计算的差值等，将耗时的结果在数据处理完后，输出出来
13. 网络发送包，虽然设置了时间间隔，但在经过网络路由之后，前后的tcp报文会粘在一起
14. 跨机器的话，是不是有用到低延时网卡（两台机器之间互传的延迟只有5us）
15. 尽量减少copy,如将头指针送传递过去，可以直接将处理函数传过去
16. 时间精度可以用us的改成ns的，直接去拿cpu的时钟会比较的快
    ```
    clock_gettime(CLOCK_REALTIME, &time_start);
    time_start.tv_nsec;
    ```
17. intel的cpu现在有睿督，你不知道具体会工作在什么主频上
18. shmq这种一个线程写到不同的q，多个线程各自读一个q的情况
19. 前面一些数据，可以不用做统计，有个warm up的过程（环形队列可能有一个热身的过程）
20. 共享内存的文件放在 /dev/shm 下
# 四、涉及数据以及耗时
1. 十档
2. 逐笔
3. 委托

# 五、其他
1. 恒生的5us
2. 使用rpc外部接收100us，30W并发
3. 光rpc耗时，可能在50us左右
4. rpc序列化和反序列化还是很耗时的
5. 一行代码
   ```
   char body = (char *)header + 1;
   #括号在前面，优先级先去转类型，然后再+1
   ```
# 六、参考地址
https://python.ctolib.com/article/compares/92177