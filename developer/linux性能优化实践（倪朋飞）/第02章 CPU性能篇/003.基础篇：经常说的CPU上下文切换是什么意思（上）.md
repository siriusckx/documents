# 一、CPU上下文切换
> CPU寄存器和程序计数器，都是CPU在运行任何任务前，必须的依赖环境，因此也被叫做CPU上下文。根据任务的不同，CPU的上下文切换就可以分为几个不同的场景，也就是进程上下文切换，线程上下文切换以及中断上下文切换。

## （一）进程上下文切换
> Linux按照特权等级，把进程的运行空间分为内核空间和用户空间，内核空间（Ring0）具有最高权限，可以直接访问所有资源。用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。
1. 一次系统调用的过程，其实是发生了两次CPU上下文切换。
2. 系统调用过程通常称为特权模式切换，而不是上下文切换。
3. 进程在什么时候会被调度到CPU上运行？
   1. 当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待CPU的进程运行。
   2. 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。
   3. 当进程通过睡眠函数sleep这样的方法将自己主动挂起时，自然也会重新调度。
   4. 当优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。
   5. 发生硬件中断时，CPU上的进程会被中断挂起，转而执行内核中的中断服务程序。
   
## （二）线程上下文切换
1. 线程与进程最大的区别在于，线程是调度的最小单位，进程则是资源拥有的基本单位。
   >所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。所对，对于线程和进程，我们可以这么理解。
   1. 当进程只有一个线程时，可以认为进程就等于线程
   2. 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。
   3. 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。
2. 线程的上下文切换时就可以分为两种情况
   1. 前后两个线程属于不同的进程，此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样的。
   2. 前后两个线程属于同一个进程，此时，因为虚拟内存是共享的，所以切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据，寄存器等不共享的数据。

## （三）中断上下文切换
1. 为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件
2. 跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。
3. 中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括CPU寄存器、内核堆栈、硬件中断参数等。