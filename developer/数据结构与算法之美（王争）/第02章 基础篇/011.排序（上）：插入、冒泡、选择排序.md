# 一、如何分析一个“排序算法”?
## （一）排序算法的执行效率
1. 最好情况、最坏情况、平均情况时间复杂度
   >有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。
2. 时间复杂度的系数、常数、低阶
3. 比较效数和交换（或移动次数）
## （二）排序算法的内存消耗
1. 原地排序
   >特指空间复杂度是O(1)的排序算法。
## （三）排序算法的稳定性
1. 稳定性
   >这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。不变的这种叫做稳定的排序算法，前后顺序发生变化这种，叫做不稳定的排序算法。
   1. 例子：订单要按照金额由小到大，金额相同的订单，按照下单时间从前往后排序。

# 二、时间复杂度为O(n^2)的排序算法
## （一）冒泡排序（Bubble Sort）
>冒泡排序只会操作相邻的两个数据。每次冒泡操作会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换，一次冒泡会让至少一个元素移动到它应该的位置，重复n次，就完成了n个数据的排序工作。
1. 冒泡排序的优化
   >当某次冒泡操作已经没有数据时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。
2. 冒泡排序是原地排序算法，并且是稳定的，对于冒泡排序最好时间复杂度是O(n)，最坏时间复杂度是O(n^2),平均时间复杂度可使用如下方法进行概算：
   1. 有序度：是数组中具有有序元素对的个数，数据表达式是
   ```
   a[i] <= a[j]，如果 i < j
   ```
   2. 满有序度：完全有序的数组的有序度，对于一个元素为n的数组，满有序度为 n*(n-1)/2
   3. 逆有序度，有序度的反面。逆有序度 = 满有序度 - 有序度
   >冒泡排序包含两个原子操作，比较和交换，每交换一次，有序度就加1，不管算法怎么改进，交换次数总是确定的，即为逆序度。对于平均情况取个中间值，则为n*(n-1)/4
3. 写冒泡排序的决窍在于交换：对单次冒泡时，元素比较的边界值的处理n-i。
## （二）插入排序
> 首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。
1. 插入排序是原地排序，同时也是稳定的排序算法，其最好时间复杂度为O(n)，最坏时间复杂度为O(n^2)，平均时间复杂度为O(n^2)。
1. 写插入排序的决窍在于移动：对元素移动的处理,从后到前移动。

## （三）选择排序
> 选择排序与插入排序在思想上比较想似，不过它是将未排序中的最小元素找出来依次放到排序区。其最好、最坏、平均时间复杂度都为O(n^2)

## （四）总结
1. 在冒泡、插入、选择排序中，插入排序最优，虽然时间复杂度为冒泡排序都一样，但是冒泡排序做swap操作，比插入排序做移位操作要复杂一些，耗时会较多。

# 链接
[算法动态展示https://visualgo.net/en](https://visualgo.net/en)