# 立项服务与进程管理
>首先，我们得有个项目，那就要有立项服务。对应到 Linux 操作系统中就是**创建进程**。创建进程的系统调用叫**fork**。

>在 Linux 里，要创建一个新的进程，需要一个老的进程调用 fork 来实现，其中老的进程叫**父进程**，新的进程叫**子进程**。

> 一个项目的执行是很复杂的，需要涉及公司各个部门的工作，比如说：项目管理部分需要给这个项目开好 Jira 和 Wiki，会议室管理部要为这个项目分配会议室等等。
> 所以，我们现在有两种方式，一种是列一个清单，清单里面写明每个新项目组都要开哪些账号。但是，这样每次有项目，都要重新配置一遍新的 Jira、Wiki、复杂得很。另一种方式就是咱们程序员常用的方式， CTRL/C + CTRL/V。也就是说，如果想为新项目建立一套 Jira，但又觉得一个个填 Jira 里面的选项太麻烦，那就可以拷贝一个别人的，然后根据新项目的实际情况，将相应的配置改改。

>Linux 就是这样想的，当父进程调用 fork 创建进程的时候，子进程将各个系统为父进程创建的数据结构也全部拷贝一份，甚至连程序代码也是拷贝过来的。对于 fork 系统调用的返回值，如果当前进程是子进程，就返回 0 ；如果当前进程是父进程，就返回子进程的进程号。这样首先在返回值这里就有了一个区分，然后通过 if-else 语句判断，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求另一个系统调用 **execve** 来执行另一个程序，这个时候，子进程和父进程就彻底分道杨镳，也就产生一个分支（fork）了。

>作为一个外包公司老板，有了新项目当然会分给手下做，但是当公司刚起步的时候呢？没有下属，只好自己上了。先建立 **项目运行体系**，等后面再做项目的时候，就都按这个来。对于操作系统也一样，启动的时候先创建一个所有用户进程的“祖宗进程”。

>有时候，父进程要关心子进程的运行情况，这毕竟是自己身上掉下来的肉。有个系统调用 **waitpid** , 父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进行运行完了没有，成功与否。

# 会议室管理与内存管理
> 项目启动之后，每个项目组有独立的会议室，存放自己项目相关的数据，每个项目组都感觉自己有独立的办公室空间。在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的**进程内存空间**。

>项目执行计划书肯定是要放进去的，因为执行过程中肯定要不断地看。对于进程的内存空间来讲，放程序代码的这部分，我们称为**代码段（Code Segment）**。

>项目执行的过程中，会产生一些架构图、流程图，这些也会放在会议室里面。有的画在白板上，讨论完了，进入下个主题就会擦了；有的画在纸和本子上，讨论的时候会翻出来，不讨论的时候堆在那里，会保留比较长的一段时间，除非指明的确不需要了才会去销毁。对于进程的内存空间来讲，放进程运行中产生数据的这部分，我们称为**数据段（Data Segment）**。其中局部变量的这部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了，这部分称为**栈（Stack）**，也有动态分配的，会较长时间保存，指明才销毁的，这部分称为**堆（Heap）**。

>一个进程的内存空间是很大的，32 位是 4G, 64 位的就更大了，我们不可能有这么多物理内存。就像一个公司的会议室是有限的，作为老板，你不可能事先给项目组分配好。哪有这么多的会议室，一定是需要的时候再分配。所以，进程自己不用的部分就不用管，只有进程要去使用部分内存的时候，才会使用内存管理的系统调来登记，说自己马上就要用了，希望分配一部分内存给它，但是这还不代表真的就对应到了物理内存。只有真的写入数据的时候，发现没有对应物理内存，才会触发一个中断，现分配物理内存。

>**brk** 和 **mmap** 是两个在堆里面分配内存的系统调用，当分配的内存数量比较小的时候，使用**brk**，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了。当分配的内存数量比较大的时候，使用**mmap**，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。

# 档案库管理与文件管理
>项目执行计划书要保存在档案库里，有一些需要长时间保存，这样哪怕公司暂时停业，再次经营的时候还可以继续使用。同样，程序、文档、照片等，哪怕关机再开机也能不丢的，就需要放在文件系统里面。文件之所以能做到这一点，一是因为**介质**，另一方面是因为**格式**。公司之所以强调资料库，也是希望将一些知识固化为标准格式，放在一起进行管理，无论多少人来人走，都不影响公司业务。对于文件的操作，无非就是打开`open`文件、`close`文件，对于没有的文件，需要创建`create`文件，打开文件后，可以使用`lseek`跳到文件的某个位置，也可以对文件的内容进行读`read`写`write`。

>Linux 里有一个特点，就是一切皆文件。
* 启动一个进程，需要一个程序文件，这是一个**二进制文件**。
* 启动的时候，要加载一些配置文件，例如 yml、properties等，这是文本文件；启动之后会打印一些日志，如果写到硬盘上，也是**文本文件**。
* 如果把日志打印到交互控制台上，这其实也是一个文件，是标准输出 **stdout 文件**。
* 这个进程的输出可以作为另一个进程的输入，这种方式称为**管道**，管道也是一个文件。
* 进程可以通过网络和其他进程进行通信，建立的**Socket**，也是一个文件。
* 进程需要访问外部设备，**设备**也是一个文件。
* 文件都被存储在文件夹里面，其实**文件夹**也是一个文件。
* 进程运行起来，要想看到进程运行的情况，会在 `/proc` 下面有对应的**进程号**，还是一系列文件。
>每个文件，Linux都会分配一个**文件描述符（File Descriptor）**，这是一个整数。有了这个文件描述符，我们就可以使用系统调用，查看或者干预进行运行的方方面面。