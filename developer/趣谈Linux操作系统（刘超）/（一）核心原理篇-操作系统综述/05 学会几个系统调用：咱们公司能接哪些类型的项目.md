# 立项服务与进程管理
>首先，我们得有个项目，那就要有立项服务。对应到 Linux 操作系统中就是**创建进程**。创建进程的系统调用叫**fork**。

>在 Linux 里，要创建一个新的进程，需要一个老的进程调用 fork 来实现，其中老的进程叫**父进程**，新的进程叫**子进程**。

> 一个项目的执行是很复杂的，需要涉及公司各个部门的工作，比如说：项目管理部分需要给这个项目开好 Jira 和 Wiki，会议室管理部要为这个项目分配会议室等等。
> 所以，我们现在有两种方式，一种是列一个清单，清单里面写明每个新项目组都要开哪些账号。但是，这样每次有项目，都要重新配置一遍新的 Jira、Wiki、复杂得很。另一种方式就是咱们程序员常用的方式， CTRL/C + CTRL/V。也就是说，如果想为新项目建立一套 Jira，但又觉得一个个填 Jira 里面的选项太麻烦，那就可以拷贝一个别人的，然后根据新项目的实际情况，将相应的配置改改。

>Linux 就是这样想的，当父进程调用 fork 创建进程的时候，子进程将各个系统为父进程创建的数据结构也全部拷贝一份，甚至连程序代码也是拷贝过来的。对于 fork 系统调用的返回值，如果当前进程是子进程，就返回 0 ；如果当前进程是父进程，就返回子进程的进程号。这样首先在返回值这里就有了一个区分，然后通过 if-else 语句判断，如果是父进程，还接着做原来应该做的事情；如果是子进程，需要请求另一个系统调用 **execve** 来执行另一个程序，这个时候，子进程和父进程就彻底分道杨镳，也就产生一个分支（fork）了。

>作为一个外包公司老板，有了新项目当然会分给手下做，但是当公司刚起步的时候呢？没有下属，只好自己上了。先建立 **项目运行体系**，等后面再做项目的时候，就都按这个来。对于操作系统也一样，启动的时候先创建一个所有用户进程的“祖宗进程”。

>有时候，父进程要关心子进程的运行情况，这毕竟是自己身上掉下来的肉。有个系统调用 **waitpid** , 父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进行运行完了没有，成功与否。

# 会议室管理与内存管理
> 项目启动之后，每个项目组有独立的会议室，存放自己项目相关的数据，每个项目组都感觉自己有独立的办公室空间。在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的**进程内存空间**。

>项目执行计划书肯定是要放进去的，因为执行过程中肯定要不断地看。对于进程的内存空间来讲，放程序代码的这部分，我们称为**代码段（Code Segment）**。

>项目执行的过程中，会产生一些架构图、流程图，这些也会放在会议室里面。有的画在白板上，讨论完了，进入下个主题就会擦了；有的画在纸和本子上，讨论的时候会翻出来，不讨论的时候堆在那里，会保留比较长的一段时间，除非指明的确不需要了才会去销毁。对于进程的内存空间来讲，放进程运行中产生数据的这部分，我们称为**数据段（Data Segment）**。其中局部变量的这部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了，这部分称为**栈（Stack）**，也有动态分配的，会较长时间保存，指明才销毁的，这部分称为**堆（Heap）**。

>一个进程的内存空间是很大的，32 位是 4G, 64 位的就更大了，我们不可能有这么多物理内存。就像一个公司的会议室是有限的，作为老板，你不可能事先给项目组分配好。哪有这么多的会议室，一定是需要的时候再分配。所以，进程自己不用的部分就不用管，只有进程要去使用部分内存的时候，才会使用内存管理的系统调来登记，说自己马上就要用了，希望分配一部分内存给它，但是这还不代表真的就对应到了物理内存。只有真的写入数据的时候，发现没有对应物理内存，才会触发一个中断，现分配物理内存。

>**brk** 和 **mmap** 是两个在堆里面分配内存的系统调用，当分配的内存数量比较小的时候，使用**brk**，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了。当分配的内存数量比较大的时候，使用**mmap**，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。

# 档案库管理与文件管理
>项目执行计划书要保存在档案库里，有一些需要长时间保存，这样哪怕公司暂时停业，再次经营的时候还可以继续使用。同样，程序、文档、照片等，哪怕关机再开机也能不丢的，就需要放在文件系统里面。文件之所以能做到这一点，一是因为**介质**，另一方面是因为**格式**。公司之所以强调资料库，也是希望将一些知识固化为标准格式，放在一起进行管理，无论多少人来人走，都不影响公司业务。对于文件的操作，无非就是打开`open`文件、`close`文件，对于没有的文件，需要创建`create`文件，打开文件后，可以使用`lseek`跳到文件的某个位置，也可以对文件的内容进行读`read`写`write`。

>Linux 里有一个特点，就是一切皆文件。
* 启动一个进程，需要一个程序文件，这是一个**二进制文件**。
* 启动的时候，要加载一些配置文件，例如 yml、properties等，这是文本文件；启动之后会打印一些日志，如果写到硬盘上，也是**文本文件**。
* 如果把日志打印到交互控制台上，这其实也是一个文件，是标准输出 **stdout 文件**。
* 这个进程的输出可以作为另一个进程的输入，这种方式称为**管道**，管道也是一个文件。
* 进程可以通过网络和其他进程进行通信，建立的**Socket**，也是一个文件。
* 进程需要访问外部设备，**设备**也是一个文件。
* 文件都被存储在文件夹里面，其实**文件夹**也是一个文件。
* 进程运行起来，要想看到进程运行的情况，会在 `/proc` 下面有对应的**进程号**，还是一系列文件。
>每个文件，Linux都会分配一个**文件描述符（File Descriptor）**，这是一个整数。有了这个文件描述符，我们就可以使用系统调用，查看或者干预进行运行的方方面面。

# 项目异常处理与信号处理
>当项目遇到异常情况，例如项目中断，做到一半不做了。这时候就需要发送一个**信号（Signal）**给项目组。经常遇到的信号有以下几种：
1. 键盘输入 `Ctrl + C`，这是中断的信，正在执行的命令就会中止退出。
2. 非法访问内存。
3. 硬件故障。
4. 用户进程通过 `kill` 函数，将一个用户信号发送给另一个进程。

>对于一些不严重的信号，可以忽略，该干啥干啥，但是像`SIGKILL(用于终止一个进程的信号)` 和 `SIGSTOP（用于中止一个进程的信号）`是不能忽略的。可以执行对于该信号的默认动作。每种信号都定义了默认的动作，也可以提供信号处理函数，可以通过`sigaction`系统调用，注册一个信号处理函数。

# 项目组间沟通与进程间通信
>项目组之间的沟通方式有很多种，我们来一一规划。
1. 首先就是发个消息，不需要一段很长的数据，这种方式称为**消息队列（Message Queue）**.由于一个公司内的多个项目组沟通时，这个消息队列是在内核里的，我们可以通过`msgget`创建一个新的队列，`msgsnd`将消息发送到消息队列，而消息接收方可以使用`msgrcv`从队列中取消息。
2. 当两个项目组需要交互的信息比较大的时候，可以使用**共享内存**的方式，也即两个项目组共享一个会议室（这样数据就不需要拷贝来拷贝去）。这时，我们可以通过`shmget`创建一个共享内存块，通过`shmat`将共享内存映射到自己的内存空间，然后就可以读写了。但是，两个项目组共同访问一个会议室里面的数据，就会存在“竞争”的问题，如果大家同时修改同一块数据咋办？这就需要有一种方式，让不同的人能够排他地访问，这就是信号量的机制`Semaphore`。对于只允许一个人访问的需求，我们可以将信号量设为 1 。当一个人要访问的时候，先调用 `sem_wait` 。如果这时没人访问，则占用这个信号量，他就可以开始访问。如果这时另一个人要访问，也会调用 sem_wait。由于前一个人已经在访问了，所以后面这个人就必须等待上一个人访问完之后才能访问。当上一个访问完毕后，会调用 `sem_post` 将信号量释放，于是下一个人等待结束，可以访问这个资源了。

# 公司间沟通与网络通信
>不同机器的通过网络相互通信，要遵循相同的网络协议，也即 **TCP/IP网络协议栈**。网络服务是通过套接字 `Socket` 来提供服务的。我们可以通过 `Socket`系统调用建立一个`Socket`。`Socket`也是一个文件，也有一个文件描述符，也可以通过读写函数进行通信。

# 查看源代码中的系统调用
> 对于 64 位操作系统，找到 `unistd_64.h` 文件，里面有对于系统调用的定义。

# 中介与 Glibc
>如果你做过开发，你会觉得刚才讲的和平时咱们调用的函数不太一样。这是因为，平时你并没有直接使用系统调用。虽然咱们的办事大厅已经很方便了，但是为了对用户更友好，我们还可以使用中介 `Glibc`，有事情找它就行，它会转换为系统调用，帮你调用。

>Glibc 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。 Glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装。

>每个特定的系统调用对应了至少一个 Glibc 封装的库函数，有时候 Glibc 一个单独的 API 可能调用多个系统调用，也有时候，多个 API 也可能只对应同一个系统调用。

> 有个命令 `strace` ，常用来跟踪进程执行时系统调用和所接收的信号。

# 总结
![Linux系统调用](../img/Linux系统调用.jpg)