# 第一章 简介和概述
## 1.1 内核的任务
   * 程序的角度——增加的计算机
   * 并发运行时——资源管理程序
   * 内核的角度——库

## 1.2 实现策略
   * 微内核——模块划分清晰，模块切换消耗CPU时间，实际应用进展较慢。
   * 宏内核——功能间相互调用，可能会嵌套，Linux使用的是这种策略，还使用了模块的热插拔功能，来弥补一些缺陷。

## 1.3 内核组成部分
### 1.3.1 进程、进程切换、调度
   * 进程——传统上，在UNIX上运行的应用程序、服务器、及其他程序等。
   * 进程切换——通过在撤销进程的CPU资源之前保存进程所有与状态相关的要素，并将进程置于空闲状态，在重新激活进程时，则将保存的状态原样恢复。
   * 调度——确定哪个进程在CPU上运行多长时间的过程。

### 1.3.2 UNIX进程
   > linux对进程采用了一种层次系统，每个进程都依赖于一个父进程。内核启动init程序作为第一个进程，该进程负责进一步的系统初始化操作。可通过pstree命令查看进程树。UNIX操作系统中有两种创建新进程的机制，分别是fork和exec。
   * fork：可以创建当前进程的一个副本，父进程和子进程只有PID(进程ID)不同。通过写时复制（copy on write）技术，使得fork操作更有效。
   * exec： 将一个程序加载到当前进程的内存中并执行。
   > 除了重量级进程（有时也称为UNIX进程）之外，还有一种形式是线程（有时也称为轻量级进程）。本质上一个进程可能由若干线程组成，这些线程共享同样的数据和资源，但可能执行程序中不同的代码路径。由于线程和进程共享同样的地址空间，主程序自动就可以访问接收到的数据，因此除了为防止线程访问同一内存而采取的互斥机制外，就不需要什么通信了。Linux用clone方法创建线程。其工作方式类似于fork,但启用了精确的检查。

### 1.3.3 地址空间与特权级别
   * 使用缩写KiB、MiB、GiB作为容量单位，分别表示$2^{10}$、 $2^{20}$、 $2^{30}$字节。  
   * CPU的字长决定了所能管理的地址空间的最大长度。对32位系统,是$2^{32}B=4GiB$，对64位处理器,可以管理$2^{64}B=16TiB$。  
   * 地址空间的最大长度与实际可用的物理内存数量无关,因此被称为`虚拟地址空间`。
   * Linux将虚拟地址空间划分为两个部分，分别称为`内核空间`和`用户空间`
   * 系统中每个用户进程都有自身的虚拟地址范围,从0到TASK_SIZE。用户空间之上的区域（从TASK_SIZE到$2^{32}$或$2^{64}$）保留给内核使用,用户进程不能访问.TASK_SIZE是一个特定于计算机体系结构的常数,把地址空间按给定比例划分为两个部分。如：在IAT-32系统中，地址空间是在3GiB处划分,因此每个进程的虚拟地址空间为3GiB。由于虚拟地址空间的总长度是4GiB,所以内核空间有1GiB可用。
   * 这种划分与可用的内存数量无关，由于地址空间虚拟化的结果,每个用户进程都认为自身有3GiB内存，各个系统进程的用户空间是完全彼此分离的。而虚拟地址空间顶部的内容空间总是同样的,无论当前执行的是哪个进程。
   * 所有的现代CPU都提供了几种特权级别，进程可以驻留在某一特权级别。每个级别都有各种限制。
   * IA-32体系结构使用4种特权级别构成的系统，各级别可以看作是环，内环能够访问更多的功能，外环则较少，如[图1-4：特权级别环状系统](./img/linux.core.1.4.png)，但linux只使用g两种不同的状态:`核心态`和`用户态`,两种状态的关键差别在于对高于TASK_SIZE的内存区域的访问。
   * 从用户状态到核心态的切换通过系统调用的特定转换手段来完成,且系统调用的执行因具体系统而不同。
   * 普通进程→（想要操作输入/输出装置）→向内核发出请求→内核检查进程是否允许执行想要的操作→代表进程执行所需操作→返回到用户态。
   * 除了代表用户程序执行代码之外,内核可以由异步硬件中断激活,然后在```中断上下文```中运行。
   
