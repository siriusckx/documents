# 精通正则表达式
## 第1章正则表达式入门
* 特殊字符
   * 元字符：充当语法的作用
* 文字：文本，充当单词的作用
* 正则表达式，需要按照字符来进行逐一理解
* 字符组：[]
   * 字符组内部只有“-”字符才是元字符，其他的被当作普通字符
   * 连接字符“-”,作为字符组第一个字符“[-”时为普通字符
* 忽略大小写 -i
* 元字符
   * 本身为元字符的特殊字符
   * 配合“\”后作为元字符序列，起元字符的作用
      * '\<' 单词开头
      * '\>' 单词结尾
      * '\1' 支持反向引用的工作中，指第1组括号匹配的文本
      * '\2' 支持反向引用的工作中，指第2组括号匹配的文本
      * '\3' 支持反向引用的工作中，指第3组括号匹配的文本
* 将元字符变成普通字符，在元字符前加'\\'
* 需要权衡，匹配符合要求的文本，同时忽略不符合要求的文本

## 第2章 入门示例拓展
* '\t' 在字符串和正则表达式当中，都代码制表符Tab。
* (.\*|\t\*) 与[.\t]* 的区别
   * (.*|\t*) 它能够匹配若干个空格(也可以没有)，以及若干个制表符（也可以没有）,不过并不允许制表符和空格符的混合体。
   * [.\t]* 与上一个相比，允许制表符和空格符的混合体。
* 对shell来说，空格符就是一个元字符,它用来分隔命令和参数,或者参数与参数。
* 在许多shell中,单引号是元字符,单引号内的字符串中的字符不需要被当作元字符处理。
* 零宽断言
   > 顺序环视相当于在当前位置右侧附加一个条件，所以它的匹配尝试是从当前位置开始的，然后向右尝试匹配，直到某一位置使得匹配成功或失败为止。而逆序环视的特殊处在于，它相当于在当前位置左侧附加一个条件，所以它不是在当前位置开始尝试匹配的，而是从当前位置左侧某一位置开始，匹配到当前位置为止，报告匹配成功或失败。
   
   > 逆序环视样例
   ```
   echo "aa<p>one</p>bb<div>two</div>cc"  

   <(?!\/?p\b)[^>]+>
   ```
   * perl
   * grep
   > 需要加参数 -P 来表示使用Perl的正则流派。
   * vim
   * **java**
   > Java中虽然顺序环视和逆序环视都支持，但是逆序环视只支持长度确定的表达式，逆序环视中量词只支持“?”，不支持其它长度不定的量词。长度确定时，引擎可以向左查找固定长度的位置作为起点开始尝试匹配，而如果长度不确定时，就要从当前位置向左逐个位置开始尝试匹配，不成功则回溯，再向左侧位置进行尝试匹配，然后重复以上过程，直到匹配成功，或是尝试到位置0处以后，报告匹配失败，处理的复杂度是显而易见的。**目前只有.NET中支持不确定长度的逆序环视**。
   * **javascript** 
   > 只支持正向环视，不支持逆向环视
* 捕获型括号()和非捕获型括号(?:)
   > 捕获型括号需要将捕获的文本保存到$1类似的变量当中。非捕获型括号，不保存匹配的内容，速度会更快一些。
* <!\w)(?=\w)|(?<=\w)(?!\w)) 相当于 \b，在不支持\b的正则中，可以这样使用。
* '^\$'、'^\s\$'、'^ \t\r\n$' 的区别
   * '^\$'只匹配位置
   * '^\s$'的匹配
      > 因为「\s」能够匹配换行符，所以整个表达式的意义就不再是“寻找空行及只包括空白字符的行”，而是“寻找连续、空行和只包括空白字符的行的结合”。也就是说，如果我们找到多个连续的这样的文本行，一个「^\s＊$」就能够匹配它们。在作替换的时候,这样的好处在于，只会留下一个\<p\>，而不是像以前那样有多少空行就留下多少\<p\>




参考：  
[正则表达式的几种引擎](http://www.xuebuyuan.com/1361558.html)  
[正则表达式101](http://regex.zjmainstay.cn/)  