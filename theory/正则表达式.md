# 精通正则表达式
## 第1章正则表达式入门
* 特殊字符
   * 元字符：充当语法的作用
* 文字：文本，充当单词的作用
* 正则表达式，需要按照字符来进行逐一理解
* 字符组：[]
   * 字符组内部只有“-”字符才是元字符，其他的被当作普通字符
   * 连接字符“-”,作为字符组第一个字符“[-”时为普通字符
* 忽略大小写 -i
* 元字符
   * 本身为元字符的特殊字符
   * 配合“\”后作为元字符序列，起元字符的作用
      * '\<' 单词开头
      * '\>' 单词结尾
      * '\1' 支持反向引用的工作中，指第1组括号匹配的文本
      * '\2' 支持反向引用的工作中，指第2组括号匹配的文本
      * '\3' 支持反向引用的工作中，指第3组括号匹配的文本
* 将元字符变成普通字符，在元字符前加'\\'
* 需要权衡，匹配符合要求的文本，同时忽略不符合要求的文本

## 第2章 入门示例拓展
* '\t' 在字符串和正则表达式当中，都代码制表符Tab。
* (.\*|\t\*) 与[.\t]* 的区别
   * (.*|\t*) 它能够匹配若干个空格(也可以没有)，以及若干个制表符（也可以没有）,不过并不允许制表符和空格符的混合体。
   * [.\t]* 与上一个相比，允许制表符和空格符的混合体。
* 对shell来说，空格符就是一个元字符,它用来分隔命令和参数,或者参数与参数。
* 在许多shell中,单引号是元字符,单引号内的字符串中的字符不需要被当作元字符处理。
* 零宽断言
   > 顺序环视相当于在当前位置右侧附加一个条件，所以它的匹配尝试是从当前位置开始的，然后向右尝试匹配，直到某一位置使得匹配成功或失败为止。而逆序环视的特殊处在于，它相当于在当前位置左侧附加一个条件，所以它不是在当前位置开始尝试匹配的，而是从当前位置左侧某一位置开始，匹配到当前位置为止，报告匹配成功或失败。
   
   > 逆序环视样例
   ```
   echo "aa<p>one</p>bb<div>two</div>cc"  

   <(?!\/?p\b)[^>]+>
   ```
   * perl
   * grep
   > 需要加参数 -P 来表示使用Perl的正则流派。
   * vim
   * **java**
   > Java中虽然顺序环视和逆序环视都支持，但是逆序环视只支持长度确定的表达式，逆序环视中量词只支持“?”，不支持其它长度不定的量词。长度确定时，引擎可以向左查找固定长度的位置作为起点开始尝试匹配，而如果长度不确定时，就要从当前位置向左逐个位置开始尝试匹配，不成功则回溯，再向左侧位置进行尝试匹配，然后重复以上过程，直到匹配成功，或是尝试到位置0处以后，报告匹配失败，处理的复杂度是显而易见的。**目前只有.NET中支持不确定长度的逆序环视**。
   * **javascript** 
   > 只支持正向环视，不支持逆向环视
* 捕获型括号()和非捕获型括号(?:)
   > 捕获型括号需要将捕获的文本保存到$1类似的变量当中。非捕获型括号，不保存匹配的内容，速度会更快一些。
* <!\w)(?=\w)|(?<=\w)(?!\w)) 相当于 \b，在不支持\b的正则中，可以这样使用。
* '^\$'、'^\s\$'、'^ \t\r\n$' 的区别
   * '^\$'只匹配位置
   * '^\s$'的匹配
      > 因为「\s」能够匹配换行符，所以整个表达式的意义就不再是“寻找空行及只包括空白字符的行”，而是“寻找连续、空行和只包括空白字符的行的结合”。也就是说，如果我们找到多个连续的这样的文本行，一个「^\s＊$」就能够匹配它们。在作替换的时候,这样的好处在于，只会留下一个\<p\>，而不是像以前那样有多少空行就留下多少\<p\>
* 在学习任何一门支持正则表达式的语言时，我们需要注意两点：
   * 正则表达式的流派。
   * 该语言运用正则表达式的方式。

## 第三章 正则表达式的特性和流派概览
* 在某种特定的宿主语言或工具软件中使用正则表达式时，主要有3个问题值得注意:
   * 支持的元字符，以及这些元字符的意义。这通常称为正则表达式的“流派”。
   * 正则表达式与语言或工具的“交互”interface方式。譬如如何进行正则表达式操作，容许进行哪些操作,以及这些操作的目标文件类型。
   * 正则表达式引擎如何将表达式应用到文本。语言或工具的设计者实现正则表达式的方法,对正则表达式的结果有重要的影响。
* POSIX-Portable Operating System Interface(可移植操作系统接口),将各种常见的流派分为两类：
   * Basic Regular Expressions(BREs)
   * Extended Regular Expressions(EBRs)  

   |正则表达式特性|BREs|EREs|
   |:--|:--|:--|
   |点号、^、$、[...]、[^...]|√|√|
   |任意数量量词|*|*|
   |+和?量词| |+ ?|
   |区间量词|\\{min,max\\}|\{min,max\}|
   |分组|\\(...\\)|\(...\)|
   |量词可否作用于括号|√|√|
   |反向引用|\1到\9||
   |多选结构||√|

* 一般来说，程序设计语言有3种处理正则表达式的方式：
   * **集成式**：正则表达式是直接内建在语言之中的。如Perl。集成式处理方法减轻了程序员的负担,因为它隐藏了一些工作,如正则表达式的预处理、准备匹配、应用正则表达式,返回结果。
   * **程序式**：正则表达式不属于低级语法,普通的函数接收普通的字符串,把他们作为正则表达式进行处理,或者由不同的函数进行不同的、关系到一个或多个正则表达式的操作。
   * **面向对象式**：和程序式处理很像，以Java为例：
      * 检查正则表达式，将它编译为能进行不区分大小匹配的内部形式,得到一个"Pattern"对象。`Pattern pattern = Pattern.compile(regex);`
      * 将它与欲匹配的文本联系起来，得到一个“Matcher”对象。`Matcher matcher = pattern.matcher(string);`
      * 应用这个正则表达式，检查之前与之建立联系的文本，是否存在匹配，返回结果。`boolean res =matcher.find();`
      * 如果存在匹配，提取捕获括号内的子表达式匹配的文本,以第1个为例。`matcher.group(0)`
   * **函数式处理的例子**
      * Java也提供了一些函数式处理的方式来节省工作量，如：`Pattern.matches（…）`，该函数会自动在正则表达式两端添加「^…$」。`String类的matches`。这种办法不如合理使用面向对象的程序有效率，所以不适宜在对时间要求很高的循环中使用，但是“随手（casual）”用起来非常方便。
* 点号的特殊说明
   * POSIX规定，点号不能匹配NUL(值为0的字符)，尽管大多数脚本语言容许文本中出现NULL(而且可以用点号来匹配)
   * 点号,在通常情况下不能匹配换行符，而排除型字符组[^＂]通常都可以。
## 第四章 表达式的匹配原理
* 部分程序及其所使用的正则引擎
 
|引擎类型|程序|
|:--|:--|
|DFA|awk(大多数版本)、egrep(大多数版本)、flex、lex、MySQL、Procmail|
|传统型NFA|GNU Emacs、Java、javaScript、grep(大多数版本)、less、more、.NET语言、PCRE     Library、Perl、PHP(所有三套正则库)、Python、Ruby、sed(大多数版本)、vi|
|POSIX NFA|mawk、Mortice Kern System’Utilities、GNU Emacs(明确指定使用)|
|DFA/NFA混合|GNU awk、GNU grep/egrep、Tcl|

* 识别程序支持哪种正则引擎
   * 是否传统NFA
      > 首先,看看忽略优先量词是否得到支持？是：传统型NFA; 否：可能是DFA或者POSIX NFA。如：  
      文本：nfa not  
      正则："nfa|nfa not"  
      结果：只匹配了nfa，则为传统型NFA，如果匹配了 nfa not ，则此引擎要么是POSIX NFA,要么是DFA。
   * DFA还是POSIX NFA:
      > DFA 不支持捕获型括号（capturing parentheses）和回溯（backreferences），这一点有助于判断，不过，也存在同时使用两种引擎的混合系统，在这种系统中，如果没有使用捕获型括号，就会使用DFA。如：  
      文本：=XX======================  
      正则：X(.*)*X  
      结果：如果执行需要花很长时间，就是NFA（如果上一项测试显示这不是传统型NFA，那么它肯定是POSIX NFA）。如果时间很短，就是DFA，或者是支持某些高级优化的NFA。如果显示堆栈超溢（stack overflow），或者超时退出，那么它是NFA引擎。






参考：  
[正则表达式的几种引擎](http://www.xuebuyuan.com/1361558.html)  
[正则表达式101](http://regex.zjmainstay.cn/)  